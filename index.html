document.addEventListener('DOMContentLoaded', function() {
    // Slider-Funktionalität
    const slider = document.getElementById('reviewsSlider');
    const prevArrow = document.querySelector('.prev-arrow');
    const nextArrow = document.querySelector('.next-arrow');
    const sliderWrapper = document.querySelector('.reviews-slider-wrapper');
    
    // Slider-Elemente und Konfiguration
    const originalSlides = slider.querySelectorAll('.review-card');
    const slideWidth = 320; // Breite einer Slide (inkl. margin)
    let currentSlide = 0;
    const visibleSlides = window.innerWidth < 768 ? 1 : 3;
    let isTransitioning = false;
    
    // Erstelle einen wirklich zirkulären Slider durch Klonen von Slides
    function setupCircularSlider() {
        // Klone die ersten und letzten Slides für den nahtlosen Übergang
        originalSlides.forEach((slide, index) => {
            if (index < visibleSlides) {
                // Klone die ersten Slides und füge sie am Ende hinzu
                const clone = slide.cloneNode(true);
                clone.classList.add('clone');
                slider.appendChild(clone);
            }
            if (index >= originalSlides.length - visibleSlides) {
                // Klone die letzten Slides und füge sie am Anfang hinzu
                const clone = slide.cloneNode(true);
                clone.classList.add('clone');
                slider.insertBefore(clone, originalSlides[0]);
            }
        });
        
        // Setze die Position initial auf die echten ersten Slides (nach den geklonten)
        currentSlide = visibleSlides;
        slider.style.transform = `translateX(-${slideWidth * currentSlide}px)`;
    }
    
    // Initialisiere den Slider
    function initSlider() {
        // Slides klonen für den zirkulären Effekt
        setupCircularSlider();
        
        // Aktualisiere die Slides-Referenz nach dem Klonen
        const slides = slider.querySelectorAll('.review-card');
        const maxSlides = slides.length;
        
        // Slider-Dots erstellen
        const dotsContainer = document.createElement('div');
        dotsContainer.className = 'slider-dots';
        
        const numberOfDots = originalSlides.length;
        
        for (let i = 0; i < numberOfDots; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot';
            if (i === 0) dot.classList.add('active');
            
            dot.addEventListener('click', function() {
                goToSlide(i + visibleSlides);
            });
            
            dotsContainer.appendChild(dot);
        }
        
        const reviewsSection = document.querySelector('.reviews-slider-container');
        reviewsSection.appendChild(dotsContainer);
    }
    
    // Event-Listeners für die Pfeile
    prevArrow.addEventListener('click', function() {
        if (!isTransitioning) {
            goToSlide(currentSlide - 1);
        }
    });
    
    nextArrow.addEventListener('click', function() {
        if (!isTransitioning) {
            goToSlide(currentSlide + 1);
        }
    });
    
    // Funktion zum Wechseln der Slides mit nahtloser zirkulärer Navigation
    function goToSlide(slideIndex) {
        const slides = slider.querySelectorAll('.review-card');
        const maxPosition = slides.length - 1;
        
        isTransitioning = true;
        
        // Animation zur angegebenen Slide
        slider.style.transition = 'transform 0.5s ease';
        slider.style.transform = `translateX(-${slideWidth * slideIndex}px)`;
        currentSlide = slideIndex;
        
        // Warte auf das Ende der Animation
        slider.addEventListener('transitionend', function handleTransition() {
            slider.removeEventListener('transitionend', handleTransition);
            
            // Überprüfe, ob wir am Anfang oder Ende der geklonten Slides sind
            if (currentSlide <= visibleSlides - 1) {
                // Wenn wir am geklonten Anfang sind, springe ohne Animation zum echten Ende
                slider.style.transition = 'none';
                currentSlide = originalSlides.length + (visibleSlides - 1);
                slider.style.transform = `translateX(-${slideWidth * currentSlide}px)`;
            } else if (currentSlide >= originalSlides.length + visibleSlides) {
                // Wenn wir am geklonten Ende sind, springe ohne Animation zum echten Anfang
                slider.style.transition = 'none';
                currentSlide = visibleSlides;
                slider.style.transform = `translateX(-${slideWidth * currentSlide}px)`;
            }
            
            // Aktualisiere die aktiven Dots
            updateDots();
            isTransitioning = false;
        }, { once: true });
    }
    
    // Dots aktualisieren
    function updateDots() {
        const dots = document.querySelectorAll('.dot');
        // Berechne den Index der originalen Slide (ohne die geklonten)
        const activeDotIndex = (currentSlide - visibleSlides) % originalSlides.length;
        
        dots.forEach((dot, index) => {
            if (index === activeDotIndex) {
                dot.classList.add('active');
            } else {
                dot.classList.remove('active');
            }
        });
    }
    
    // Automatisches Sliden
    let autoSlideInterval;
    
    function startAutoSlide() {
        autoSlideInterval = setInterval(function() {
            if (!isTransitioning) {
                goToSlide(currentSlide + 1);
            }
        }, 5000); // Alle 5 Sekunden
    }
    
    function stopAutoSlide() {
        clearInterval(autoSlideInterval);
    }
    
    // Event-Listener für Hover-Effekt
    sliderWrapper.addEventListener('mouseenter', stopAutoSlide);
    sliderWrapper.addEventListener('mouseleave', startAutoSlide);
    
    // Touch-Events für mobile Geräte
    let touchStartX = 0;
    let touchEndX = 0;
    
    slider.addEventListener('touchstart', function(e) {
        touchStartX = e.changedTouches[0].screenX;
        stopAutoSlide();
    }, {passive: true});
    
    slider.addEventListener('touchend', function(e) {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
        startAutoSlide();
    }, {passive: true});
    
    function handleSwipe() {
        if (isTransitioning) return;
        
        const swipeThreshold = 50;
        if (touchEndX < touchStartX - swipeThreshold) {
            // Swipe nach links: nächste Slide
            goToSlide(currentSlide + 1);
        } else if (touchEndX > touchStartX + swipeThreshold) {
            // Swipe nach rechts: vorherige Slide
            goToSlide(currentSlide - 1);
        }
    }
    
    // Fenster-Resize-Event
    window.addEventListener('resize', function() {
        // Passe die sichtbaren Slides basierend auf Fensterbreite an
        const newVisibleSlides = window.innerWidth < 768 ? 1 : 3;
        if (newVisibleSlides !== visibleSlides) {
            // Hier müsste ein Reset des Sliders erfolgen
            location.reload(); // Einfache Lösung: Seite neu laden
        }
    });
    
    // FAQ-Accordion Funktionalität
    const faqQuestions = document.querySelectorAll('.faq-question');
    
    faqQuestions.forEach(question => {
        question.addEventListener('click', function() {
            // Toggle aktive Klasse
            this.classList.toggle('active');
            
            // Antwort anzeigen/ausblenden
            const answer = this.nextElementSibling;
            if (answer.style.maxHeight) {
                answer.style.maxHeight = null;
            } else {
                answer.style.maxHeight = answer.scrollHeight + "px";
            }
        });
    });
    
    // Initialisiere beim Laden der Seite
    initSlider();
    startAutoSlide();
});
